#include "../all.cpp"






class Solution {
public:
    int integerBreak(int n) {
        if (n == 2)
        {
            return 1;
        }
        if (n == 3)
        {
            return 2;
        }
        if (n == 4)
        {
            return 4;
        }
        int d2_cnt = 2;
        int d3_cnt = 0;
        for (int i = 4; i < n; ++i)
        {
            if (d2_cnt > 0)
            {
                --d2_cnt;
                ++d3_cnt;
            }
            else
            {
                d2_cnt = 2;
                --d3_cnt;
            }
        }
        int ret = 1 << d2_cnt;
        for (int i = 0; i < d3_cnt; ++i)
        {
            ret *= 3;
        }
        return ret;
    }
};

// 根据提示，找到规律，尽可能的将数拆分成2和3，
// 具体证明，可以见https://bbs.csdn.net/topics/390663126中提到的，
// ============下面是摘取===============
// 1. 容易证明，当n<=4时，最好的分法是不分，此时序列乘积=n。
// 2. 容易证明，当n>4时，n最优分解后的乘积必定>n。
// 假设将数字N分解为x[1]+x[2]+...+x[k]，(x[1]<=x[2]<=...<=x[k])为最优的分解，其序列为最优序列。
// 3. 当k>1时，显然有x[1]>1 (如果x[1]=1，则去掉x[1]，并将x[2]加上1，这样得到的序列乘积必定大于原始序列乘积)
// 4. 另外，当k>1时，如果x[1]=2，则有x[2]>2 (如果x[1]=x[2]=2，则将去掉x[1]，将x[2]加上2，这样得到的序列乘积必定不小于原始序列乘积)
// 5. 再有，在序列中，必定有x[k]<=4 (如果有x[k]>4，则根据2,必定存在序列x[k]=y[1]+y[2]+...+y[s]使得y[1]*y[2]*...*y[s]>x[k]，这样序列x[1]*x[2]*...*x[k-1]*y[1]*...*y[s]比原序列更优)
// 6. 在最优序列中，不可能存在2个或2个以上的4(假设有x[i]=x[i+1]=4，则可以将x[i],x[i+1]求和后重新分解为3+3+2，这样得到的序列乘积比原先的乘积更大)
// 7. 在最优序列中，不可能同时出现2和4(假设序列中x[a]=2, x[b]=4，则将x[a]和x[b]求和后重新分解为3+3，这样得到的序列乘积比原先乘积更大)
// 所以嘛，最后的结论就是：对于所有可以进行分割的数字n(即n>4)，其最优分割就是先按照3来进行分割，如果分完之后剩下余数为2，则序列2,3,...,3就是最优序列。如果最后剩下余数为1，则少分一块，凑出一个4，然后序列3,3,...,3,4就是最优序列。